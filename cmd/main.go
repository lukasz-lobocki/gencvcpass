package cmd

import (
	crand "crypto/rand"
	"encoding/binary"
	"fmt"
	"log"
	"math/big"
	mrand "math/rand"
	"os"
	"strings"
	"unicode"

	"github.com/fatih/color"
	"github.com/spf13/cobra"
)

// Variables for semantic versioning
var (
	semVer            string
	commitHash        string
	isGitDirty        string
	isSnapshot        string
	goOs              string
	goArch            string
	gitUrl            string
	builtBranch       string
	builtDate         string
	semReleaseVersion string = semVer +
		func(pre string, txt string) string {
			if len(txt) > 0 {
				return pre + txt
			} else {
				return ""
			}
		}("+", goArch) +
		func(pre string, txt string) string {
			if len(txt) > 0 {
				return pre + txt
			} else {
				return ""
			}
		}(".", builtBranch) +
		func(pre string, txt string) string {
			if len(txt) > 0 {
				return pre + txt
			} else {
				return ""
			}
		}(".", commitHash)
)

var config tConfig // Holds configuration.

var rootCmd = &cobra.Command{
	Use:               "gencvcpass",
	Args:              cobra.NoArgs,
	Short:             "Generates CVC password",
	Long:              `Generates consonant-vowel-consonant patterned password`,
	Version:           semReleaseVersion,
	DisableAutoGenTag: true, // Do not add footer to autogenerated help.

	CompletionOptions: cobra.CompletionOptions{HiddenDefaultCmd: true},

	Run: func(cmd *cobra.Command, args []string) { main() },
}

// Variables for loggers
var (
	loggingLevel int         // Global logging level, see MAX_LOGGING_LEVEL.
	logInfo      *log.Logger // Blue logger, for info.
	logWarning   *log.Logger // Yellow logger, for warning.
	logError     *log.Logger // Red logger, for error.
)

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() {
	err := rootCmd.Execute()
	if err != nil {
		os.Exit(1)
	}
}

// init preseeds cobra environment
func init() {
	initLoggers()

	rootCmd.PersistentFlags().IntVar(&loggingLevel, "logging", 0, // Adding global ie. persistent logging level flag.
		fmt.Sprintf("logging level [0...%d] (default 0)", MAX_LOGGING_LEVEL))

	rootCmd.Flags().IntVarP(&config.setsNum, "sets", "s", 5, "number of sets between separators")
	rootCmd.Flags().IntVarP(&config.upperNum, "upper", "u", 2, "number of uppercase letters")
	rootCmd.Flags().IntVarP(&config.digitsNum, "digits", "d", 2, "number of digits")
	rootCmd.Flags().StringVar(&config.separator, "sep", "-", "separator character")

	// Hide help command.
	rootCmd.SetHelpCommand(&cobra.Command{Hidden: true})
	//Do not sort flags.
	rootCmd.Flags().SortFlags = false
	//Do not sort commands.
	cobra.EnableCommandSorting = false
}

// main function
func main() {
	// Validate input.
	if config.setsNum < 1 {
		logError.Fatalf("sets=%d must be equal or greater than 1", config.setsNum)
	}

	// Get string of CVCs
	cvcsString, err := getCVCCVCsString(config.setsNum)
	if err != nil {
		logError.Fatalln(err)
	}
	if loggingLevel >= 2 {
		logInfo.Printf("cvcsString= %s", cvcsString)
	}

	// Swap random characters to UPPER and digits
	passString, err := swapUpperAndDigits(cvcsString, config.setsNum, config.upperNum, config.digitsNum)
	if err != nil {
		logError.Fatalln(err)
	}
	if loggingLevel >= 2 {
		logInfo.Printf("passString= %s", passString)
	}

	// Split it to chunks
	chunks, err := splitIntoChunks(passString, CHUNKSIZE)
	if err != nil {
		logError.Fatalln(err)
	}
	if loggingLevel >= 2 {
		logInfo.Printf("chunks= %v", chunks)
	}

	// Merge chunks with separator
	password := strings.Join(chunks, config.separator)

	// Output the result
	fmt.Println(password)
}

// swapUpperAndDigits replaces a given number of unique random characters
// in a string with their uppercase equivalents and digits.
func swapUpperAndDigits(s string, setsNum int, countUpper int, countDigits int) (string, error) {
	// Validate input
	if countUpper < 0 || countUpper > setsNum*2 {
		return "", fmt.Errorf("upper=%d must be between 0 and the number of sets=%d * 2", countUpper, setsNum)
	}
	if countDigits < 0 || countDigits > setsNum*2 {
		return "", fmt.Errorf("digits=%d must be between 0 and the number of sets=%d * 2", countDigits, setsNum)
	}

	upper := func(x int) int {
		return 3 * x // every 1st character of CVC tripplet -1
	}
	digits := func(x int) int {
		return 3*x + 2 // every 3rd character of CVC tripplet -1
	}
	// Get, shuffle and cut the clices
	upperSlice := getRandomPiece(
		getSlice(upper, setsNum*2),
		countUpper)
	digitSlice := getRandomPiece(
		getSlice(digits, setsNum*2),
		countDigits)

	runes := []rune(s)

	// Loop through UPPER indices
	for _, element := range upperSlice {
		// Swap to UPPER
		runes[element] = unicode.ToUpper(runes[element])
	}

	// Loop through DIGITS indices
	for _, element := range digitSlice {
		// Get random digit
		randomDigitIndex, err := crand.Int(crand.Reader, big.NewInt(int64(len(DIGITS))))
		if err != nil {
			return "", err
		}
		randomDigit := DIGITS[int(randomDigitIndex.Int64())]
		// Swap to random digit
		runes[element] = rune(randomDigit)
	}
	return string(runes), nil
}

// getRandomPiece shuffles given slice and returns its starting pieces
func getRandomPiece(slice []int, lenght int) (seq []int) {
	// Create a new Rand instance using our crypto-safe source.
	r := mrand.New(newCryptoRandSource())
	r.Shuffle(len(slice), func(i, j int) {
		slice[i], slice[j] = slice[j], slice[i]
	})
	return slice[:lenght]
}

// newCryptoRandSource creates a new crypto-safe random source.
func newCryptoRandSource() *cryptoRandSource {
	return &cryptoRandSource{}
}

// Seed is a no-op for a cryptographically secure source.
func (s *cryptoRandSource) Seed(seed int64) {}

// Int63 returns a non-negative pseudo-random 63-bit integer from the crypto/rand source.
func (s *cryptoRandSource) Int63() int64 {
	var b [8]byte
	_, err := crand.Read(b[:])
	if err != nil {
		logError.Fatalf("crypto/rand: failed to read random bytes. %v", err)
	}
	// Mask off the sign bit to ensure a positive number
	return int64(binary.LittleEndian.Uint64(b[:]) & (1<<63 - 1))
}

// getSlice returns a sequential slice of iterated function results
func getSlice(function operation, iterations int) (seq []int) {
	for i := 0; i <= iterations-1; i++ {
		term := compute(function, i)
		seq = append(seq, term)
	}
	return seq
}

// compute takes an 'operation' function and an integer as parameter
func compute(op operation, a int) int {
	return op(a)
}

// splitIntoChunks divides a string into chunks of a given size.
func splitIntoChunks(s string, chunkSize int) (chunks []string, err error) {
	// Validate input
	if chunkSize <= 0 {
		return chunks, fmt.Errorf("size of a chunk must be greater than 0")
	}

	for i := 0; i < len(s); i += chunkSize {
		end := min(i+chunkSize, len(s)) // len, in case the remainder is shorter than chunkSize
		chunks = append(chunks, s[i:end])
	}
	return chunks, nil
}

// getCVCCVCsString returns CVCCVCs repeated
func getCVCCVCsString(repetitions int) (cvcsString string, err error) {
	for i := 1; i <= (repetitions * 2); i++ { // times 2 for each chunk to be CVCCVC
		cvc, err := getCVC()
		if err != nil {
			return "", err
		}
		cvcsString += cvc
	}
	return cvcsString, nil
}

// getCVC returns random consonant-vowel-consonant string
func getCVC() (cvc string, err error) {

	var (
		useConsonant bool // true for consonant, false for vowel
	)

	for i := 1; i <= 3; i++ { // 3-letter CVC
		var charSet string
		useConsonant = !useConsonant // Alternate between consonant and vowel
		if useConsonant {
			charSet = CONSONANTS
		} else {
			charSet = VOWELS
		}

		// Use crypto/rand for secure random number generation.
		randomIndex, err := crand.Int(crand.Reader, big.NewInt(int64(len(charSet))))
		if err != nil {
			return "", err
		}
		idx := int(randomIndex.Int64())

		char := string(charSet[idx]) // pick at random from charSet
		cvc += char

	}
	return cvc, nil
}

// initLoggers initiates loggers with colors and headers
func initLoggers() {
	hiCyan := color.New(color.FgHiCyan).SprintFunc()
	hiYellow := color.New(color.FgHiYellow).SprintFunc()
	hiRed := color.New(color.FgHiRed).SprintFunc()

	logInfo = log.New(os.Stderr, hiCyan("╭info\n╰"), 0)
	logWarning = log.New(os.Stderr, hiYellow("╭warning\n╰"), 0)
	logError = log.New(os.Stderr, hiRed("╭error\n╰"), 0)
}
