package cmd

import (
	"crypto/rand"
	"fmt"
	"log"
	"math/big"
	"os"
	"strings"
	"unicode"

	"github.com/fatih/color"
	"github.com/spf13/cobra"
)

var (
	semVer      string
	commitHash  string
	isGitDirty  string
	isSnapshot  string
	goOs        string
	goArch      string
	gitUrl      string
	builtBranch string
	builtDate   string
)

var config tConfig // Holds configuration.

var semReleaseVersion string = semVer +
	func(pre string, txt string) string {
		if len(txt) > 0 {
			return pre + txt
		} else {
			return ""
		}
	}("+", goArch) +
	func(pre string, txt string) string {
		if len(txt) > 0 {
			return pre + txt
		} else {
			return ""
		}
	}(".", builtBranch) +
	func(pre string, txt string) string {
		if len(txt) > 0 {
			return pre + txt
		} else {
			return ""
		}
	}(".", commitHash)

var rootCmd = &cobra.Command{
	Use:               "gencvcpass",
	Args:              cobra.NoArgs,
	Short:             "Generates CVC password.",
	Long:              `Creates consonant-vowel-consonant patterned password.`,
	Version:           semReleaseVersion,
	DisableAutoGenTag: true, // Do not add footer to autogenerated help.

	CompletionOptions: cobra.CompletionOptions{HiddenDefaultCmd: true},

	// Uncomment the following line if your bare application
	// has an action associated with it:
	Run: func(cmd *cobra.Command, args []string) { main() },
}

var (
	loggingLevel int         // Global logging level, see MAX_LOGGING_LEVEL.
	logInfo      *log.Logger // Blue logger, for info.
	logWarning   *log.Logger // Yellow logger, for warning.
	logError     *log.Logger // Red logger, for error.
)

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() {
	err := rootCmd.Execute()
	if err != nil {
		os.Exit(1)
	}
}

func init() {
	initLoggers()
	rootCmd.PersistentFlags().IntVar(&loggingLevel, "logging", 0, // Adding global ie. persistent logging level flag.
		fmt.Sprintf("logging level [0...%d] (default 0)", MAX_LOGGING_LEVEL))

	rootCmd.Flags().IntVarP(&config.setsNum, "sets", "s", 5, "number of sets between separators")
	rootCmd.Flags().IntVarP(&config.upperNum, "upper", "u", 2, "number of uppercase letters")
	rootCmd.Flags().IntVarP(&config.digitsNum, "digits", "d", 2, "number of digits")
	rootCmd.Flags().StringVar(&config.separator, "sep", "-", "separator character")

	// Hide help command.
	rootCmd.SetHelpCommand(&cobra.Command{Hidden: true})
	//Do not sort flags.
	rootCmd.Flags().SortFlags = false
	//Do not sort commands.
	cobra.EnableCommandSorting = false
}

func main() {
	var cvcsString string
	for i := 1; i <= (config.setsNum * 2); i++ {
		cvc, err := getCVC()
		if err != nil {
			logError.Fatalln(err)
		}
		cvcsString += cvc
	}
	passString, err := swapUniqueRandom(cvcsString, config.upperNum, config.digitsNum)
	if err != nil {
		logError.Fatalln(err)
	}
	chunks := SplitIntoChunks(passString, CHUNKSIZE)
	password := strings.Join(chunks, "-")
	fmt.Println(password)
}

// swapUniqueRandom replaces a given number of unique random characters
// in a string with their uppercase equivalents and digits.
func swapUniqueRandom(s string, countUpper int, countDigits int) (string, error) {
	if countUpper == 0 {
		return s, nil
	}

	// Convert the string to a slice of runes to handle Unicode characters correctly.
	runes := []rune(s)
	n := len(runes)

	// Validate input.
	if countUpper < 0 || countUpper > n {
		return "", fmt.Errorf("count must be between 0 and the length of the string")
	}

	// Use a map to keep track of the unique indices that have been chosen.
	chosenIndices := make(map[int]bool)

	// Loop until we have selected the required number of unique UPPER indices.
	for len(chosenIndices) < countUpper {
		// Generate a cryptographically secure random number between 0 and n-1.
		randomIndex, err := rand.Int(rand.Reader, big.NewInt(int64(n)))
		if err != nil {
			return "", err
		}

		idx := int(randomIndex.Int64())

		// If the index has not been chosen yet, add it to the map.
		if !chosenIndices[idx] {
			chosenIndices[idx] = true
			runes[idx] = unicode.ToUpper(runes[idx])
		}
	}

	// Loop until we have selected the required number of unique DIGITS indices, taking into account count consumed by upper
	for len(chosenIndices)-countUpper < countDigits {
		// Generate a cryptographically secure random number between 0 and n-1.
		randomIndex, err := rand.Int(rand.Reader, big.NewInt(int64(n)))
		if err != nil {
			return "", err
		}

		randomDigitIndex, err := rand.Int(rand.Reader, big.NewInt(int64(len(DIGITS))))
		if err != nil {
			return "", err
		}
		randomDigit := DIGITS[int(randomDigitIndex.Int64())]

		idx := int(randomIndex.Int64())

		// If the index has not been chosen yet, add it to the map.
		if !chosenIndices[idx] {
			chosenIndices[idx] = true
			runes[idx] = rune(randomDigit)
		}
	}

	return string(runes), nil
}

// SplitIntoChunks divides a string into chunks of a given size.
func SplitIntoChunks(s string, chunkSize int) []string {
	var chunks []string
	if chunkSize <= 0 {
		return chunks
	}

	for i := 0; i < len(s); i += chunkSize {
		end := i + chunkSize
		if end > len(s) {
			end = len(s)
		}
		chunks = append(chunks, s[i:end])
	}
	return chunks
}

func getCVC() (cvc string, err error) {

	var (
		useConsonant bool // true for consonant, false for vowel
	)

	for i := 1; i <= 3; i++ { //3-letter CVC
		var charSet string
		useConsonant = !useConsonant // Alternate between consonant and vowel
		if useConsonant {
			charSet = CONSONANTS
		} else {
			charSet = VOWELS
		}

		// Use crypto/rand for secure random number generation.
		randomIndex, err := rand.Int(rand.Reader, big.NewInt(int64(len(charSet))))
		if err != nil {
			return "", err
		}
		idx := int(randomIndex.Int64())

		char := string(charSet[idx])
		cvc += char

	}
	return cvc, nil

}

func initLoggers() {
	hiCyan := color.New(color.FgHiCyan).SprintFunc()
	hiYellow := color.New(color.FgHiYellow).SprintFunc()
	hiRed := color.New(color.FgHiRed).SprintFunc()

	logInfo = log.New(os.Stderr, hiCyan("╭info\n╰"), 0)
	logWarning = log.New(os.Stderr, hiYellow("╭warning\n╰"), 0)
	logError = log.New(os.Stderr, hiRed("╭error\n╰"), 0)
}

/*
checkLogginglevel confirms if logging level does not exceed maximum level.

	loggingLevel = 1 : often
	loggingLevel = 2 : average
	loggingLevel = 3 : seldom

For convenience it also emits some log if loggingLevel >= 1.

	'thisArgs' Values emitted to log.
*/
func checkLogginglevel(thisArgs []string) {
	if loggingLevel > MAX_LOGGING_LEVEL {
		logError.Fatalln(fmt.Errorf("%s", rootCmd.Flag("logging").Usage))
	}

	if loggingLevel >= 1 { // Show info.
		logInfo.Printf("len(args): %d. args: %#v\n", len(thisArgs), thisArgs)
		logInfo.Printf("loggingLevel: %d\n", loggingLevel)
	}
}
